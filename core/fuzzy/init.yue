import "fzy"
import "awful"
import "wibox"
import "gears"
import "beautiful"

import "core.utils.factory"
import "core.enum" as modifiers:{:EMPTY}
import "core.utils.helpers" as :bind_click_away

import "lib.overflow"
import "lib.std" as table:{:is_list, :keys, :map}, string:{:split}

DPI = beautiful.xresources.apply_dpi
Resource = factory.resource_factory!

return class
  -- Map<NUMBER, TABLE> this is NOT an array
  stack: {}
  widgets: {}
  options: {}
  new: (entries, options) =>
    -- TODO: Add more checks and validations.
    entries ??= {}
    options ??= {}
    options.sleep ??= false

    options.maximum_width ??= DPI(250)
    options.width ??= DPI(500)
    options.background ??= "#232323"

    options.prompt ??= {}
    options.prompt.background ??= "#0F0F0F"
    options.prompt.foreground ??= "#B4B4B4"
    options.prompt.dummy ??= "Search"
    options.prompt.font ??= "Comfortaa 16"

    options.prefix ??= {}
    options.prefix.image ??= Resource.magnifying_glass
    options.prefix.style ??= "*{fill:#B4B4B4;}"

    options.outline ??= {}
    options.outline.background ??= "#3B3B3B"

    options.items ??= {}
    options.items.spacing ??= 0
    @options = options

    items = wibox.widget
      step: 50
      spacing: options.items.spacing
      scrollbar_enabled: options.thumb.enabled
      layout: overflow.vertical
    for index, entry in ipairs(entries)
      do
        <- entry.widget::connect_signal("mouse::enter")
        @\select(index, {
          background: options.selected.background
          foreground: options.selected.foreground
        })
      entry.widget::connect_signal("mouse::leave", -> @\deselect(index))
      items::add(entry.widget)

    prompt = wibox.widget
      text: options.prompt.dummy
      font: options.prompt.font
      forced_width: options.prompt.width
      buttons:
        * awful.button
            modifiers: EMPTY
            button: awful.button.names.LEFT
            on_press: -> @\activate_textbox!
      forced_height: options.prompt.height
      valign: "center"
      widget: wibox.widget.textbox

    popup = awful.popup({
      hide_on_right_click: options.hide
      placement: options.place
      shape: gears.shape.rounded_rect
      maximum_width: options.maximum_width
      maximum_height: options.maximum_height
      border_color: options.outline.background
      border_width: options.outline.width
      ontop: options.ontop
      visible: options.visible
      widget: {
        {
          {
            {
              {
                {
                  nil
                  prompt
                  {
                    {
                      image: options.prefix.image
                      forced_width: options.prefix.width
                      forced_height: options.prefix.height
                      stylesheet: options.prefix.style
                      valign: "center"
                      halign: "center"
                      buttons:
                        -- mapping for the prefix button
                        * awful.button
                            modifiers: EMPTY
                            button: awful.button.names.LEFT
                            on_press: ->
                              -- execute all selected element's 
                              @\execute_stack!
                              root.fake_input("key_release", "Escape") -- Escape needs to be released first
                              @\escape!
                              @\hide!
                              @\reset!
                      widget: wibox.widget.imagebox
                    }
                    bottom: DPI(10)
                    top: DPI(10)
                    layout: wibox.container.margin
                  }
                  forced_height: DPI(50)
                  layout: wibox.layout.align.horizontal
                }
                left: DPI(15)
                right: DPI(5)
                bottom: DPI(5)
                top: DPI(5)
                layout: wibox.container.margin
              }
              fg: options.prompt.foreground
              bg: options.prompt.background
              shape: gears.shape.rounded_rect
              layout: wibox.container.background
            }
            margins: DPI(10)
            layout: wibox.container.margin
          }
          items
          layout: wibox.layout.align.vertical
        }
        bg: options.background
        forced_width: options.width
        layout: wibox.container.background
      }
    })

    @widgets =
      popup: popup
      prompt: prompt
      entries: entries
      items: items

    if options.initial
      @\select(options.initial, {
        background: options.selected.background
        foreground: options.selected.foreground
      })

    if options.sleep
      timer = do
        <- gears.timer.start_new(options.sleep)
        @\escape!
        @\hide!

      popup::connect_signal("mouse::enter", -> timer::stop!)
      -- INFO: the activate_textbox method's changed_callback function's last part
      -- i.e. we use timer::again! instead of timer::start! because timer::start! error out
      -- if timer::again! is called before somewhere else albeit could wrap timer::start!
      -- inside of pcall but that would be more sanitary than using just timer::again!
      popup::connect_signal("mouse::leave", -> timer::again!)
      -- TODO: needs some work
      @timer = timer

  activate_textbox: =>
    awful.prompt.run
      font: @options.prompt.font
      bg_cursor: @options.prompt.cursor
      textbox: @widgets.prompt
      hooks:
        *
          * EMPTY
          * "Escape"
          * ->
            if @widgets.popup.visible then @\escape!
            @\reset!
      -- ISSUE: Red zone. Prone to errors. Add more checks.
      exe_callback: (input) ->
        if not input or #input == 0 then return
        @\execute_stack(true)
        @\hide!
      -- ISSUE: Red zone. Prone to errors. Add more checks.
      changed_callback: (needle) ->
        haystacks = [entry.options.label for entry in *@widgets.entries]
        results = fzy.filter(needle, haystacks)
        @\deselect_all!
        if #results < 1 then return
        @widgets.items.children = {}
        for _, result in ipairs(results)
          -- [1] is an index on the @widgets.entries array
          entry = @widgets.entries[result[1]]
          -- [2] is an array of indices on the @widgets.entries[N].label.markup string
          @\illustrate_entry(entry, result[2], {
            background: @options.match.background
            foreground: @options.match.foreground
          })
          @widgets.items::add(entry.widget)
        @\select(results[1][1], {
          background: @options.selected.background
          foreground: @options.selected.foreground
        })
        -- pause the timer when typing and resume when typing has stopped
        @timer::again!
        collectgarbage("collect")
      done_callback: -> @widgets.prompt::set_text(@options.prompt.dummy)

  click_away: (callback) => bind_click_away(@widgets.popup, callback)

  illustrate_entry: (entry, match, ...) =>
    entry.label::set_markup @\illustrate_matches(entry.options.label, match, ...)

  ---Wrap string characters with a pango span element containing foreground and background colors.
  illustrate_matches: (text, marks, options) =>
    -- transform a string value to an array of that string's characters
    chars = split(text, "")
    for _, mark in ipairs(marks)
      -- I do not recommend using background, this is because when the element 
      background = options.background and "background='#{options.background}'" or ""
      foreground = options.foreground and "foreground='#{options.foreground}'" or ""
      chars[mark] = "<span #{background} #{foreground}>#{chars[mark]}</span>"
    table.concat(chars)

  reset: =>
    -- if there are previous match illustrations (pango markup) then reset that as well
    for _, entry in ipairs(@widgets.entries)
      entry.label::set_markup(entry.options.label)
    @widgets.items.children = [entry.widget for entry in *@widgets.entries]

  toggle: => if @widgets.popup.visible then return @\hide! else return @\show!

  show: =>
    @widgets.popup.visible = true
    @timer\again!

  hide: =>
    @widgets.popup.visible = false
    @timer\stop!

  select: (index, options) =>
    assert(options, "options should not be empty")
    assert(options.background, "options.background should not be empty")
    assert(options.foreground, "options.foreground should not be empty")

    -- ISSUE: Red zone. Prone to errors.
    check = index >= 1 and index <= #@widgets.entries
    if not check then return

    child = @widgets.entries[index].widget
    @stack[index] = index: index, widget: child
    child::set_bg(options.background)
    child::set_fg(options.foreground)

  deselect: (index) =>
    entry = @stack[index]
    if not entry then return
    @\select(index, {
      background: @widgets.entries[index].options.background
      foreground: @widgets.entries[index].options.foreground
    })
    @stack[index] = nil

  escape: =>
    root.fake_input("key_press", "Escape")
    root.fake_input("key_release", "Escape")

  execute_stack: (escape) =>
    for _, item in pairs(@stack) do @widgets.entries[item.index].options.on_press!
    @\escape!

  ---Select multiple items in the overflow by passing an array of @\select(...) params.
  select_many: (indices) =>
    assert(is_list(indices), "expected: {index:number,options:table}[]")
    for key, options in pairs(indices)
      index = options.index or options[1] or key
      @\select(index, options)

  deselect_many: (indices) =>
    assert(is_list(indices), "expected: number[]")
    for index in *indices do @\deselect(index)

  deselect_all: =>
    indices = {}
    for _, item in pairs(@stack) do indices[] = item.index
    @\deselect_many(indices)
