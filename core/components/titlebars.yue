import "core.components.surfaces"
import "core.utils.factory"

import "rubato"
import "awful"
import "gears.timer"

import "lib.tiny" as T
import "lib.functional" as :if_nil

export pacman =
  <call>: (radius, pattern) =>
    assert(radius, "pacman needs a radius")
    pattern ??= T("yellow")
    button = awful.widget.button
      resize: true
      visible: true
      image: surfaces.pacman(radius, pattern)
    button.timed = rubato.timed
      duration: 0.3
      subscribed: (position) -> button::set_image(surfaces.pacman radius, pattern, -position)
    -- no need for backcalls as this is cleaner
    button::connect_signal("mouse::enter", -> button.timed.target = 0.5)
    button::connect_signal("mouse::leave", -> button.timed.target = 0.0)
    button

pacman.minimize = (node, radius, pattern) ->
  button = pacman(radius, pattern)
  do
    <- button::connect_signal("button::press")
    ---@see https://github.com/awesomeWM/awesome/issues/3716
    timer.delayed_call((-> node.minimized = true), 0.05)
  button

pacman.maximize = (node, radius, pattern) ->
  button = pacman(radius, pattern)
  button::connect_signal("button::press", -> node.maximized = not node.maximized)
  button

pacman.close = (node, radius, pattern) ->
  button = pacman(radius, pattern)
  button::connect_signal("button::press", -> node::kill!)
  button

methman =
  <call>: (radius, pattern) =>
    assert(radius, "pacman needs a radius")
    pattern ??= T("yellow")

    button = awful.widget.button
      resize: true
      visible: true
      image: surfaces.pacman(radius, pattern)

    timed = rubato.timed
      awestore_compat: true
      duration: 0.3

    do
      (position) <- timed::subscribe
      button::set_image(surfaces.pacman radius, pattern, -position)
    do
      (position) <- timed.ended::subscribe
      if position == 0.5
        timed.target = 0.1
      elseif position == 0.1
        timed.target = 0.5

    button::connect_signal("mouse::enter", -> timed.target = 0.5)
    button::connect_signal("mouse::leave", -> timed.target = 0.0)
    button.timed = timed
    button

methman.minimize = (node, radius, pattern) ->
  button = methman(radius, pattern)
  do
    <- button::connect_signal("button::press")
    ---@see https://github.com/awesomeWM/awesome/issues/3716
    timer.delayed_call((-> node.minimized = true), 0.05)
  button

methman.maximize = (node, radius, pattern) ->
  button = methman(radius, pattern)
  button::connect_signal("button::press", -> node.maximized = not node.maximized)
  button

methman.close = (node, radius, pattern) ->
  button = methman(radius, pattern)
  button::connect_signal("button::press", -> node::kill!)
  button
