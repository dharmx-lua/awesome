import "awful" as Awful
import "gears.timer" as Timer
import "naughty" as Naughty
import "gears" as Gears
import "wibox" as Wibox
import "beautiful" as Beautiful
import "lib.overflow"

import "fzy"
import "core.enum" as modifiers:{:EMPTY}
import "core.utils.factory"
import "lib.std" as table:{:is_list, :keys}
import "lib.functional" as :if_nil

DPI = Beautiful.xresources.apply_dpi
Resource = factory.resource_factory!

export class SimpleEntry
  new: (@options) =>
    assert @options[1] or @options.label, "No label found."
    assert @options.background, "supply a options.background"
    assert @options.foreground, "supply a options.foreground"
    assert @options.icon.image, "supply a options.icon.image"
    assert @options.on_press, "supply a options.on_press"
    if type(@options.on_press) == "string" then @options.on_press = factory.spawn_wrap @options.on_press
    assert type(@options.on_press) == "function", "on_press is not a function"
    @widget = Wibox.widget
      *
        *
          *
            *
              *
                image: @options.icon.image
                stylesheet: @options.icon.style
                widget: Wibox.widget.imagebox
              margins: DPI 5
              widget: Wibox.container.margin
            bg: @options.icon.background
            shape: @options.icon.shape
            widget: Wibox.container.background
          *
            text: if_nil @options[1], @options.label
            font: "Comfortaa 14"
            widget: Wibox.widget.textbox
          spacing: DPI 10
          layout: Wibox.layout.fixed.horizontal
        margins: DPI 10
        widget: Wibox.container.margin
      bg: @options.background
      fg: @options.foreground
      forced_height: DPI 50
      buttons:
        * Awful.button modifiers: EMPTY, button: 1, on_press: @options.on_press
      widget: Wibox.container.background

export class Fuzzy
  new: (entries, options) =>
    entries = if_nil entries, {}
    options = if_nil options, {}
    options.sleep = if_nil options.sleep, false

    options.maximum_width = if_nil options.maximum_width, DPI 250
    options.width = if_nil options.width, DPI 500
    options.background = if_nil options.background, "#232323"

    options.prompt = if_nil options.prompt, {}
    options.prompt.background = if_nil options.prompt.background, "#0F0F0F"
    options.prompt.foreground = if_nil options.prompt.foreground, "#B4B4B4"
    options.prompt.dummy = if_nil options.prompt.dummy, "Search paths"
    options.prompt.font = if_nil options.prompt.font, "Comfortaa 16"

    options.prefix = if_nil options.prefix, {}
    options.prefix.image = if_nil options.prefix.image, Resource.magnifying_glass
    options.prefix.style = if_nil options.prefix.style, "*{fill:#B4B4B4;}"

    options.outline = if_nil options.outline, {}
    options.outline.background = if_nil options.outline.background, "#3B3B3B"

    options.items = if_nil options.items, {}
    options.items.spacing = if_nil options.items.spacing, 0

    @options = options
    @stack = {}
    @widgets = {}

    items = Wibox.widget
      step: 50
      spacing: options.items.spacing
      scrollbar_enabled: options.thumb.enabled
      layout: overflow.vertical
    for index, entry in ipairs entries
      entry.widget::connect_signal "mouse::enter", -> @\select index,
        background: options.selected_background
        foreground: options.selected_foreground
      entry.widget::connect_signal "mouse::leave", -> @\deselect index
      items::add entry.widget

    prompt = Wibox.widget
      text: options.prompt.dummy
      font: options.prompt.font
      forced_width: options.prompt.width
      buttons:
        * Awful.button
            modifiers: EMPTY,
            button: 1,
            on_press: -> @\activate_textbox!
      forced_height: options.prompt.height
      valign: "center"
      widget: Wibox.widget.textbox

    popup = Awful.popup
      hide_on_right_click: options.hide
      placement: options.place
      shape: Gears.shape.rounded_rect
      maximum_width: options.maximum_width
      maximum_height: options.maximum_height
      border_color: options.outline.background
      border_width: options.outline.width
      ontop: options.ontop
      visible: options.visible
      widget:
        *
          *
            *
              *
                *
                  * nil
                  * prompt
                  *
                    *
                      image: options.prefix.image
                      forced_width: options.prefix.width
                      forced_height: options.prefix.height
                      stylesheet: options.prefix.style
                      valign: "center"
                      halign: "center"
                      buttons:
                        -- mapping for the prefix button
                        * Awful.button
                            modifiers: EMPTY
                            button: 1
                            on_press: ->
                              for entry in *entries
                                if prompt.text::lower!::match if_nil(entry.options[1], entry.options.label)::lower!
                                  entry.options.on_press!
                                  root.fake_input "key_release", "Escape" -- Escape needs to be released first
                                  root.fake_input "key_press", "Escape"
                                  root.fake_input "key_release", "Escape"
                                  @\hide!
                                  @\reset!
                                  break
                      widget: Wibox.widget.imagebox
                    bottom: DPI 10
                    top: DPI 10
                    layout: Wibox.container.margin
                  forced_height: DPI 50
                  layout: Wibox.layout.align.horizontal
                left: DPI 15
                right: DPI 5
                bottom: DPI 5
                top: DPI 5
                layout: Wibox.container.margin
              fg: options.prompt.foreground
              bg: options.prompt.background
              shape: Gears.shape.rounded_rect
              layout: Wibox.container.background
            margins: DPI 10
            layout: Wibox.container.margin
          * items
          layout: Wibox.layout.align.vertical
        bg: options.background
        forced_width: options.width
        layout: Wibox.container.background

    @widgets =
      popup: popup
      prompt: prompt
      entries: entries
      items: items
    if options.initial
      @\select options.initial,
        background: options.selected_background
        foreground: options.selected_foreground
    if options.sleep
      timer = Timer.start_new options.sleep, -> @\hide!
      popup::connect_signal "mouse::enter", => timer::stop!
      popup::connect_signal "mouse::leave", => timer::start!
      @timer = timer

  activate_textbox: =>
    Awful.prompt.run
      font: @options.prompt.font
      bg_cursor: @options.prompt.cursor
      textbox: @widgets.prompt
      hooks:
        *
          * EMPTY
          * "Escape"
          * ->
            if @widgets.popup.visible
              root.fake_input "key_press", "Escape"
              root.fake_input "key_release", "Escape"
            @\reset!
      -- ISSUE: Red zone. Prone to errors.
      exe_callback: (input) ->
        if not input or #input == 0 then return
        for _, item in pairs @stack do @widgets.entries[item.index].options.on_press!
        root.fake_input "key_press", "Escape"
        root.fake_input "key_release", "Escape"
        @\hide!
      -- ISSUE: Red zone. Prone to errors.
      changed_callback: (needle) ->
        haystacks = [if_nil entry.options[1], entry.options.label for entry in *@widgets.entries]
        results = fzy.filter needle, haystacks
        @\deselect_all!
        if #results < 1 then return
        -- TODO: Add match highlights.
        @widgets.items.children = [@widgets.entries[result[1]] for result in *results]
        @\select results[1][1],
          background: @options.selected_background
          foreground: @options.selected_foreground
        -- TODO: Pause the timer when keypresses are detected and resume when keypresses have stopped
      done_callback: -> @widgets.prompt::set_text @options.prompt.dummy

  reset: => @widgets.items.children = [entry.widget for entry in *@widgets.entries]
  toggle: => @widgets.popup.visible = not @widgets.popup.visible
  hide: => @widgets.popup.visible = false
  show: => @widgets.popup.visible = true

  select: (index, options) =>
    assert options, "options should not be empty"
    assert options.background, "options.background should not be empty"
    assert options.foreground, "options.foreground should not be empty"

    -- ISSUE: Red zone. Prone to errors.
    check = index >= 1 and index <= #@widgets.entries
    if not check then return

    child = @widgets.entries[index].widget
    @stack[index] =
      index: index
      widget: child
    child::set_bg options.background
    child::set_fg options.foreground

  deselect: (index) =>
    entry = @stack[index]
    if not entry then return
    @\select index,
      background: @widgets.entries[index].options.background
      foreground: @widgets.entries[index].options.foreground
    @stack[index] = nil

  ---Select multiple items in the overflow by passing an array of @\select(...) params.
  select_many: (indices) =>
    assert is_list(indices), "expected: {index:number,options:table}[]"
    for key, options in pairs indices
      index = options.index or options[1] or key
      @\select index, options

  deselect_many: (indices) =>
    assert is_list(indices), "expected: number[]"
    for index in *indices do @\deselect index

  deselect_all: =>
    indices = {}
    for _, item in pairs @stack do table.insert indices, item.index
    @\deselect_many indices
